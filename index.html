<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- <script src="https://unpkg.com/good-dom"></script> -->
    <link rel="stylesheet" href="https://unpkg.com/css-baseline/css/3.css">
    <title>Countdown</title>
    <style>
        .animate {
            transition: all 0.5s ease-in-out 0s;
        }
        .weak-shadow {
            transition: all 0.3s ease-in-out 0s;
            box-shadow: 0 4px 5px 0 rgba(0,0,0,0.10),0 1px 10px 0 rgba(0,0,0,0.08),0 2px 4px -1px rgba(0,0,0,0.24);
        }
        .weak-shadow:hover {
            box-shadow: 0 8px 17px 2px rgba(0,0,0,0.10),0 6px 30px 5px rgba(0,0,0,0.08),0 8px 10px -7px rgba(0,0,0,0.16);
        }
    </style>
</head>
<script type="module">;(async () => {
    // 
    // 
    // Main code
    // 
    // 
    const { Elemental } = (await import("https://cdn.skypack.dev/@!!!!!/elemental@0.0.12")).default
    const Reactive = (await import("https://cdn.skypack.dev/cause-n-effect@3.0.0")).default
    const DateTime = (await import("https://cdn.skypack.dev/good-date@1.3.16")).default
    const Container = (await import("https://cdn.skypack.dev/@!vanilla/container@v1.0.5")).default
    Elemental.debug = true
    
    const {html} = new Elemental({ Container, If: (props)=>props.true?props.children:"" })
    
    document.body = html`
        <body>
            <Container verticalAlignment="center" horizontalAlignment="center" width="100%" height="10rem" backgroundColor="lightcoral" color=white>
                Howdy!
            </Container>
            <Container width="100%" horizontalAlignment="center" verticalAlignment="top">
                <${TimerCard}/>
            </Container>
        </body>
    `
    
    function CardList({}) {
        const cardContainer = html`
            <Container verticalAlignment="center" horizontalAlignment="center" width="56rem" height="50rem" backgroundColor="lightblue">
                <${TimerCard} />
            </Container>
        `
        const cardButton = html`
            <button></button>
        `
        
        
        return [ cardContainer, cardButton ]
    }
    
    function TimerCard({ style, children, ...props }) {
        const countdownAreaElement = html`<div />`
        let timeUpdate
        const timeKeeper = Reactive({
            initialValue: {
                now: (new Date()).getTime(),
                nextEvent: null,
            },
            onUpdate: timeUpdate = ()=>{
                const nextEvent = timeKeeper.$.nextEvent.$
                const now = timeKeeper.$.now.$
                if (nextEvent == null) {
                    if (countdownAreaElement.innerHTML != "Done") {
                        countdownAreaElement.innerHTML = "Done"
                    }
                } else {
                    const countdownElement = Countdown({targetUnixTime: nextEvent})
                    countdownAreaElement.innerHTML = ""
                    countdownAreaElement.appendChild(countdownElement)
                }
            }
        })
        timeUpdate()
        // update the local countdown each second
        setInterval(()=>timeKeeper.$.now = (new Date()).getTime(),1000)
        
        const element = html`
            <Container row width="55rem" horizontalAlignment="space-between" verticalAlignment="center" margin-top=2rem padding=2rem>
                <Container class="weak-shadow" horizontalAlignment="left" verticalAlignment="center" padding=2rem border-radius=2rem width=16rem>
                    ${countdownAreaElement}
                </Container>
                
                <Container class="weak-shadow" horizontalAlignment="left" verticalAlignment="center" padding=2rem border-radius=2rem>
                    <Container positionSelf="relativeToParent" right="1rem" top="1rem">
                        <span
                            style="cursor: pointer; color: lightcoral;"
                            onclick=${(event)=>{
                                console.debug(`event is:`,event)
                                element.parentElement.removeChild(element)
                            }}
                            >
                            X
                        </span>
                    </Container>
                    
                    <textarea
                        rows="4"
                        cols="20"
                        style="
                            width: 25rem;
                            height: 4rem;
                            border: none;
                            border-bottom: 2px cornflowerblue solid;
                            padding: 6px;
                            background: whitesmoke;
                            border-radius: 5px;
                            outline: none;
                        "
                        placeholder="(mm/dd/yyyy hh:mm I need to start typing)"
                        oninput=${e=>{
                            console.log("e",e)
                            // get new todo list
                            let todoList = parseUpcomingTodos(e.target.value)
                            // update the element time
                            element.nextUnixDateTime = todoList[0]&&todoList[0].dateTime.getTime()
                            // update if needed
                            if (element.nextUnixDateTime !== timeKeeper.$.nextEvent) {
                                console.debug(`updating log`,)
                                timeKeeper.$.nextEvent = element.nextUnixDateTime
                                console.debug(`timeKeeper.$.nextEvent is:`,timeKeeper.$.nextEvent)
                                console.debug(`timeKeeper.$ is:`,timeKeeper.$)
                            }
                        }}
                        />
                </Container>
            </Container>
        `
        return element
    }
    
    function Countdown({targetUnixTime}) {
        const { secondsUntil, minutesUntil, hoursUntil, daysUntil } = remainingTimeBreakdown(targetUnixTime)
        return html`
            <Container row>
                <If true=${daysUntil}>
                    <h3>${daysUntil}:</h3>
                </If>
                <If true=${hoursUntil}>
                    <h3>${hoursUntil}:</h3>
                </If>
                <If true=${minutesUntil}>
                    <h3>${minutesUntil}:</h3>
                </If>
                <h3>${secondsUntil}</h3>
            </Container>
        `
    }
        
    function parseUpcomingTodos(text, timezoneReference=(new Date())) {
        console.debug(`text is:`,text)
        let todos = []
        let reocurringTasks = []
        if (text) {
            let lines = text.split(/\n(?=\S)/)
            for (let each of lines) {
                // 
                // check for reocurring
                // 
                let reocurringMatch = each.match(/^(Sun|Mon|Tue|Wed|Thu|Fri|Sat)/i)
                if (reocurringMatch) {
                    try {
                        var { remaining: lineWithoutDays,  extraction: days} = extractFirst({ pattern: /^(\w+( *, *)?)+/,  from: each, })
                        days = days.split(",").map(each=>each.trim())
                        days = days.map(each=>{
                            if      (each.match(/^Sun/i)) { return "Sunday"    }
                            else if (each.match(/^Mon/i)) { return "Monday"    }
                            else if (each.match(/^Tue/i)) { return "Tuesday"   }
                            else if (each.match(/^Wed/i)) { return "Wednesday" }
                            else if (each.match(/^Thu/i)) { return "Thursday"  }
                            else if (each.match(/^Fri/i)) { return "Friday"    }
                            else if (each.match(/^Sat/i)) { return "Saturday"  }
                        })
                        
                        var { remaining: description ,  extraction: start} = extractFirst({ pattern: /\s*[^\s]+/,  from: lineWithoutDays, })
                        start = start.trim()
                        
                        reocurringTasks.push({ description, start, days })
                    } catch (error) {
                        console.error("Error trying to parse weekly reocurring event")
                        console.debug(`error is:`,error)
                    }
                    continue
                }
                
                // 
                // check for fixed / daily
                // 
                let match = each.match(/^(?:(\d+\/\d+\/\d+) )?(\d{1,2}):(\d{1,2})([aA][mM]|[pP][mM]) ([\s\S]*)/)
                if (match) {
                    let hour = match[2]-0
                    let minute = match[3]-0
                    let pmOrAm = match[4]
                    let time = convertTime12to24(hour, minute, pmOrAm)
                    let dateTime = new Date()
                    if (match[1] != null) {
                        dateTime = new Date((new Date(match[1])).getTime() + Math.abs(timezoneReference.getTimezoneOffset()*60000))
                    }
                    dateTime.setHours(time[0], time[1])
                    if (match[1] == null) {
                        if (dateTime.getTime() <= (new Date()).getTime()) {
                            let oneDayInMiliseconds = 24*60*60*1000
                            dateTime = new Date(dateTime.getTime()+oneDayInMiliseconds)
                        }
                    }
                    // if it is a future event
                    if (dateTime.getTime() > (new Date()).getTime()) {
                        todos.push({
                            dateTime,
                            date: match[1],
                            hour,
                            minute,
                            content: match[5],
                        })
                    }
                }
            }
        }
        todos = todos.sort((a,b)=>a.dateTime.getTime() - b.dateTime.getTime())
        
        // 
        // 
        // handle reocurring tasks
        // 
        // 
        const activeTasks = []
        let now = new DateTime
        let todayName = now.dayName
        let tomorrowName = now.add({days: 1}).dayName
        for (let each of reocurringTasks) {
            // add to today
            if (each.days.includes(todayName)) {
                let eventDateTime = new DateTime()
                eventDateTime.time = each.start
                activeTasks.push({
                    dateTime: eventDateTime,
                    date: eventDateTime.date,
                    hour: eventDateTime.hour24,
                    minute: eventDateTime.minute,
                    content: each.description,
                })
            }
            // add to tomorrow
            if (each.days.includes(tomorrowName)) {
                let eventDateTime = new DateTime().add({days: 1})
                eventDateTime.time = each.start
                activeTasks.push({
                    dateTime: eventDateTime,
                    date: eventDateTime.date,
                    hour: eventDateTime.hour24,
                    minute: eventDateTime.minute,
                    content: each.description,
                })
            }
        }
        
        // 
        // sort
        // 
        const unsortedTasks = todos.concat(activeTasks)
        now = new Date().getTime()
        const byTime = (a,b)=>a.dateTime.getTime()-b.dateTime.getTime()
        const isInTheFuture = each=>(each.dateTime.getTime()-now)>0
        const sortedTasks = ([...unsortedTasks]).filter(isInTheFuture).sort(byTime)
        return sortedTasks
    }
        
    function convertTime12to24(hours, minutes, pmOrAm) {
        if (hours == "12") {
            hours = "00"
        }
        if (pmOrAm.match(/[pP][mM]/)) {
            hours = parseInt(hours, 10) + 12
        }
        return [hours, minutes]
    }
    
    function countdownString(targetUnixTime) {
        const { secondsUntil, minutesUntil, hoursUntil, daysUntil } = remainingTimeBreakdown(targetUnixTime)
        let time = secondsUntil
        if (minutesUntil) {
            time = `${minutesUntil}:${time}`
        }
        if (hoursUntil) {
            time = `${hoursUntil}:${time}`
        }
        if (daysUntil) {
            time = `${daysUntil}:${time}`
        }
        return time
    }
    
    function remainingTimeBreakdown(targetUnixTime) {
        const currentUnixTimeInSeconds = new Date().getTime()/1000
        const timeUntil = targetUnixTime/1000 - currentUnixTimeInSeconds
        return {
            secondsUntil: padZero(Math.floor(timeUntil % 60)),
            minutesUntil: padZero(Math.floor((timeUntil/60) % 60)),
            hoursUntil: Math.floor((timeUntil/3600) % 24),
            daysUntil: Math.floor((timeUntil/86400)),
        }
    }
    
    function padZero(amount) {
        if (amount < 10) {
            return `0${amount}`
        } else {
            return amount
        }
    }
    
    function extractFirst({ pattern, from }) {
        let match = from.match(pattern)
        if (match) {
            return {
                remaining: from.slice(0, match.index)+ from.slice(match.index + match[0].length, from.length),
                extraction: match[0]
            }
        } else {
            return {
                remaining: from,
                extraction: null
            }
        }
    }
    
    
})()</script>